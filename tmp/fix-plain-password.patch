diff --git a/src/lib/password.ts b/src/lib/password.ts
--- a/src/lib/password.ts
+++ b/src/lib/password.ts
@@ -1,19 +1,45 @@
 import bcrypt from "bcryptjs";
 
 export function hashPassword(password: string, rounds = 12): Promise<string> {
   return new Promise((resolve, reject) => {
     bcrypt.hash(password, rounds, (err, hash) => {
       if (err || !hash) return reject(err ?? new Error("Failed to hash password"));
       resolve(hash);
     });
   });
 }
 
-export function verifyPassword(password: string, hash: string): Promise<boolean> {
-  return new Promise((resolve, reject) => {
-    bcrypt.compare(password, hash, (err, same) => {
-      if (err) return reject(err);
-      resolve(Boolean(same));
-    });
-  });
+function looksLikeBcrypt(value: string) {
+  return (
+    value.startsWith("$2a$") ||
+    value.startsWith("$2b$") ||
+    value.startsWith("$2y$")
+  );
+}
+
+// cryptoを使わずに（edgeでも動く）定数時間っぽい比較
+function constantTimeEqual(a: string, b: string) {
+  const enc = new TextEncoder();
+  const ab = enc.encode(a);
+  const bb = enc.encode(b);
+  if (ab.length !== bb.length) return false;
+  let diff = 0;
+  for (let i = 0; i < ab.length; i++) diff |= ab[i] ^ bb[i];
+  return diff === 0;
+}
+
+export function verifyPassword(password: string, stored: string): Promise<boolean> {
+  // bcrypt 形式なら bcrypt compare、それ以外は平文比較
+  if (looksLikeBcrypt(stored)) {
+    return new Promise((resolve, reject) => {
+      bcrypt.compare(password, stored, (err, same) => {
+        if (err) return reject(err);
+        resolve(Boolean(same));
+      });
+    });
+  }
+
+  return Promise.resolve(constantTimeEqual(password, stored));
 }
diff --git a/src/lib/airtable.ts b/src/lib/airtable.ts
--- a/src/lib/airtable.ts
+++ b/src/lib/airtable.ts
@@ -101,14 +101,16 @@ export async function getUserByEmail(email: string) {
   const records = await listAll<UserFields>(TABLE_USERS, params, { cache: "no-store" });
   const r = records[0];
   if (!r) return null;
 
   const f = r.fields;
-  if (!f.Email || !f.Name || !f.PasswordHash) return null;
+  // Name列が無い（または空）ケースは Email を表示名に使う
+  if (!f.Email || !f.PasswordHash) return null;
 
   return {
     id: r.id,
     email: f.Email,
-    name: f.Name,
+    name: (f.Name && f.Name.trim()) ? f.Name : f.Email,
     role: f.Role,
     passwordHash: f.PasswordHash,
   };
 }
@@ -132,7 +134,7 @@ export async function listAnnouncements() {
   const params = new URLSearchParams();
   params.set(
     "filterByFormula",
-    `AND({IsActive}=TRUE(), OR(IS_BLANK({PublishFrom}), {PublishFrom}<=NOW()), OR(IS_BLANK({PublishTo}), {PublishTo}>=NOW()))`
+    `AND({IsActive}=TRUE(), OR({PublishFrom}=BLANK(), {PublishFrom}<=NOW()), OR({PublishTo}=BLANK(), {PublishTo}>=NOW()))`
   );
   params.set("sort[0][field]", "IsPinned");
   params.set("sort[0][direction]", "desc");
@@ -162,7 +164,7 @@ export async function listNotifications() {
   const params = new URLSearchParams();
   params.set(
     "filterByFormula",
-    `AND({IsActive}=TRUE(), OR(IS_BLANK({PublishFrom}), {PublishFrom}<=NOW()), OR(IS_BLANK({PublishTo}), {PublishTo}>=NOW()))`
+    `AND({IsActive}=TRUE(), OR({PublishFrom}=BLANK(), {PublishFrom}<=NOW()), OR({PublishTo}=BLANK(), {PublishTo}>=NOW()))`
   );
   params.set("sort[0][field]", "SortOrder");
   params.set("sort[0][direction]", "asc");